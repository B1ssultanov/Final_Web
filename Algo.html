<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms</title>
    <link rel="stylesheet" href="Algos.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <nav>
        <a href="Home.html">Home</a>
        <ul>
            <li><a href="#">Sign In</a></li>
            <li><a href="#">Register</a></li>
        </ul>
    </nav>
    <!-- <div id="background_rhombus">
        <img src="images/Green_rhombus_background.jpg" alt="" style="width: 69vw">
    </div> -->
    <div>
        <div id="algorithmsList">
            <ol>
                <li>
                    <div>
                        <h2 id="1" onclick="buttonHeader(this.id)" style="text-align: center;">Binary Search Algorithm</h2>
                        <div id="11" style="display: none;">
                            <img src="images/Algo_binary_search.gif" alt="" style="width: 70%; margin-left: 10%;">
                            <pre>
                                <code> 
// C++ program to implement recursive Binary Search
#include &lt;bits/stdc++.h&gt;
using namespace std;

// A recursive binary search function. It returns
// location of x in given array arr[l..r] is present,
// otherwise -1
int binarySearch(int arr[], int l, int r, int x)
{
    if (r &gt;= l) {
        int mid = l + (r - l) / 2;

        // If the element is present at the middle
        // itself
        if (arr[mid] == x)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] &gt; x)
            return binarySearch(arr, l, mid - 1, x);

        // Else the element can only be present
        // in right subarray
        return binarySearch(arr, mid + 1, r, x);
    }

    // We reach here when element is not
    // present in array
    return -1;
}

int main(void)
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int x = 10;
    int n = sizeof(arr) / sizeof(arr[0]);
    int result = binarySearch(arr, 0, n - 1, x);
    (result == -1)
        ? cout &lt;&lt; &quot;Element is not present in array&quot;
        : cout &lt;&lt; &quot;Element is present at index &quot; &lt;&lt; result;
    return 0;
}
                                </code>
                            </pre>
                            <!-- <div data-pym-src="https://www.jdoodle.com/embed/v0/5Es1" style="width: 120%"></div>
                            <script src="https://www.jdoodle.com/assets/jdoodle-pym.min.js" type="text/javascript"></script> -->
                        </div>
                    </div>
                </li>
                <li>
                    <div>
                        <h2 id="2" onclick="buttonHeader(this.id)" style="text-align: center;">Breadth First Search (BFS) Algorithm</h2>
                        <div id="21" style="display: none">
                            <img src="images/Algo_BFS.gif" alt="" style="width: 70%; margin-left: 10%;">
                            <pre>
                                <code>
// Program to print BFS traversal from a given
// source vertex. BFS(int s) traverses vertices
// reachable from s.
#include&lt;bits/stdc++.h&gt;
using namespace std;

// This class represents a directed graph using
// adjacency list representation
class Graph
{
	int V; // No. of vertices

	// Pointer to an array containing adjacency
	// lists
	vector&lt;list&lt;int&gt;&gt; adj;
public:
	Graph(int V); // Constructor

	// function to add an edge to graph
	void addEdge(int v, int w);

	// prints BFS traversal from a given source s
	void BFS(int s);
};

Graph::Graph(int V)
{
	this-&gt;V = V;
	adj.resize(V);
}

void Graph::addEdge(int v, int w)
{
	adj[v].push_back(w); // Add w to v&rsquo;s list.
}

void Graph::BFS(int s)
{
	// Mark all the vertices as not visited
	vector&lt;bool&gt; visited;
	visited.resize(V,false);

	// Create a queue for BFS
	list&lt;int&gt; queue;

	// Mark the current node as visited and enqueue it
	visited[s] = true;
	queue.push_back(s);

	while(!queue.empty())
	{
		// Dequeue a vertex from queue and print it
		s = queue.front();
		cout &lt;&lt; s &lt;&lt; &quot; &quot;;
		queue.pop_front();

		// Get all adjacent vertices of the dequeued
		// vertex s. If a adjacent has not been visited,
		// then mark it visited and enqueue it
		for (auto adjecent: adj[s])
		{
			if (!visited[adjecent])
			{
				visited[adjecent] = true;
				queue.push_back(adjecent);
			}
		}
	}
}

// Driver program to test methods of graph class
int main()
{
	// Create a graph given in the above diagram
	Graph g(4);
	g.addEdge(0, 1);
	g.addEdge(0, 2);
	g.addEdge(1, 2);
	g.addEdge(2, 0);
	g.addEdge(2, 3);
	g.addEdge(3, 3);

	cout &lt;&lt; &quot;Following is Breadth First Traversal &quot;
		&lt;&lt; &quot;(starting from vertex 2) \n&quot;;
	g.BFS(2);

	return 0;
}

                            </code></pre>
                            <!-- <div data-pym-src="https://www.jdoodle.com/embed/v0/5Es9" style="width: 120%"></div>
                            <script src="https://www.jdoodle.com/assets/jdoodle-pym.min.js" type="text/javascript"></script> -->
                        </div>
                    </div>
                </li>
                <li>
                    <div>
                        <h2 id="3" onclick="buttonHeader(this.id)" style="text-align: center;">Depth First Search (DFS) Algorithm</h2>
                        <div id="31" style="display: none">
                            <img src="images/Algo_DFS.gif" alt="" style="width: 70%; margin-left: 10%;">
                            <pre>
                                <code>
// C++ program to print DFS traversal from
// a given vertex in a given graph
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Graph class represents a directed graph
// using adjacency list representation
class Graph {
public:
	map&lt;int, bool&gt; visited;
	map&lt;int, list&lt;int&gt; &gt; adj;

	// function to add an edge to graph
	void addEdge(int v, int w);

	// DFS traversal of the vertices
	// reachable from v
	void DFS(int v);
};

void Graph::addEdge(int v, int w)
{
	adj[v].push_back(w); // Add w to v&rsquo;s list.
}

void Graph::DFS(int v)
{
	// Mark the current node as visited and
	// print it
	visited[v] = true;
	cout &lt;&lt; v &lt;&lt; &quot; &quot;;

	// Recur for all the vertices adjacent
	// to this vertex
	list&lt;int&gt;::iterator i;
	for (i = adj[v].begin(); i != adj[v].end(); ++i)
		if (!visited[*i])
			DFS(*i);
}

// Driver's code
int main()
{
	// Create a graph given in the above diagram
	Graph g;
	g.addEdge(0, 1);
	g.addEdge(0, 2);
	g.addEdge(1, 2);
	g.addEdge(2, 0);
	g.addEdge(2, 3);
	g.addEdge(3, 3);

	cout &lt;&lt; &quot;Following is Depth First Traversal&quot;
			&quot; (starting from vertex 2) \n&quot;;

	// Function call
	g.DFS(2);

	return 0;
}
                                </code>
                            </pre>
                            <!-- <div data-pym-src="" style="width: 120%"></div>
                            <script src="https://www.jdoodle.com/assets/jdoodle-pym.min.js" type="text/javascript"></script> -->
                        </div>
                    </div>
                </li>
                
                <li>
                    <div>
                        <h2 id="4" onclick="buttonHeader(this.id)" style="text-align: center;">Merge Sort Algorithm</h2>
                        <div id="41" style="display: none">
                            <img src="images/Algo_Merge_sort.gif" alt="" style="width: 70%; margin-left: 10%;">
                            <pre>
                                <code>
// C++ program for Merge Sort
#include &lt;iostream&gt;
using namespace std;

// Merges two subarrays of array[].
// First subarray is arr[begin..mid]
// Second subarray is arr[mid+1..end]
void merge(int array[], int const left, int const mid,
		int const right)
{
	auto const subArrayOne = mid - left + 1;
	auto const subArrayTwo = right - mid;

	// Create temp arrays
	auto *leftArray = new int[subArrayOne],
		*rightArray = new int[subArrayTwo];

	// Copy data to temp arrays leftArray[] and rightArray[]
	for (auto i = 0; i &lt; subArrayOne; i++)
		leftArray[i] = array[left + i];
	for (auto j = 0; j &lt; subArrayTwo; j++)
		rightArray[j] = array[mid + 1 + j];

	auto indexOfSubArrayOne
		= 0, // Initial index of first sub-array
		indexOfSubArrayTwo
		= 0; // Initial index of second sub-array
	int indexOfMergedArray
		= left; // Initial index of merged array

	// Merge the temp arrays back into array[left..right]
	while (indexOfSubArrayOne &lt; subArrayOne
		&amp;&amp; indexOfSubArrayTwo &lt; subArrayTwo) {
		if (leftArray[indexOfSubArrayOne]
			&lt;= rightArray[indexOfSubArrayTwo]) {
			array[indexOfMergedArray]
				= leftArray[indexOfSubArrayOne];
			indexOfSubArrayOne++;
		}
		else {
			array[indexOfMergedArray]
				= rightArray[indexOfSubArrayTwo];
			indexOfSubArrayTwo++;
		}
		indexOfMergedArray++;
	}
	// Copy the remaining elements of
	// left[], if there are any
	while (indexOfSubArrayOne &lt; subArrayOne) {
		array[indexOfMergedArray]
			= leftArray[indexOfSubArrayOne];
		indexOfSubArrayOne++;
		indexOfMergedArray++;
	}
	// Copy the remaining elements of
	// right[], if there are any
	while (indexOfSubArrayTwo &lt; subArrayTwo) {
		array[indexOfMergedArray]
			= rightArray[indexOfSubArrayTwo];
		indexOfSubArrayTwo++;
		indexOfMergedArray++;
	}
	delete[] leftArray;
	delete[] rightArray;
}

// begin is for left index and end is
// right index of the sub-array
// of arr to be sorted */
void mergeSort(int array[], int const begin, int const end)
{
	if (begin &gt;= end)
		return; // Returns recursively

	auto mid = begin + (end - begin) / 2;
	mergeSort(array, begin, mid);
	mergeSort(array, mid + 1, end);
	merge(array, begin, mid, end);
}

// UTILITY FUNCTIONS
// Function to print an array
void printArray(int A[], int size)
{
	for (auto i = 0; i &lt; size; i++)
		cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;;
}

// Driver code
int main()
{
	int arr[] = { 12, 11, 13, 5, 6, 7 };
	auto arr_size = sizeof(arr) / sizeof(arr[0]);

	cout &lt;&lt; &quot;Given array is \n&quot;;
	printArray(arr, arr_size);

	mergeSort(arr, 0, arr_size - 1);

	cout &lt;&lt; &quot;\nSorted array is \n&quot;;
	printArray(arr, arr_size);
	return 0;
}
                                </code>
                            </pre>
                            <!-- <div data-pym-src="" style="width: 120%"></div>
                            <script src="https://www.jdoodle.com/assets/jdoodle-pym.min.js" type="text/javascript"></script> -->
                        </div>
                    </div>
                </li>
                <li>
                    <div>
                        <h2 id="5" onclick="buttonHeader(this.id)" style="text-align: center;">Dijkstra's Algorithm</h2>
                        <div id="51" style="display: none">
                            <img src="images/Algo_Dijkstra.gif" alt="" style="width: 70%; margin-left: 10%;">
                            <pre>
                                <code>
// A C++ program for Dijkstra's single source shortest path algorithm.
// The program is for adjacency matrix representation of the graph

#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;

// Number of vertices in the graph
#define V 9

// A utility function to find the vertex with minimum distance value, from
// the set of vertices not yet included in shortest path tree
int minDistance(int dist[], bool sptSet[])
{
	// Initialize min value
	int min = INT_MAX, min_index;

	for (int v = 0; v &lt; V; v++)
		if (sptSet[v] == false &amp;&amp; dist[v] &lt;= min)
			min = dist[v], min_index = v;

	return min_index;
}

// A utility function to print the constructed distance array
int printSolution(int dist[], int n)
{
	printf(&quot;Vertex Distance from Source\n&quot;);
	for (int i = 0; i &lt; V; i++)
		printf(&quot;%d \t\t %d\n&quot;, i, dist[i]);
}

// Function that implements Dijkstra's single source shortest path algorithm
// for a graph represented using adjacency matrix representation
void dijkstra(int graph[V][V], int src)
{
	int dist[V]; // The output array. dist[i] will hold the shortest
	// distance from src to i

	bool sptSet[V]; // sptSet[i] will be true if vertex i is included in shortest
	// path tree or shortest distance from src to i is finalized

	// Initialize all distances as INFINITE and stpSet[] as false
	for (int i = 0; i &lt; V; i++)
		dist[i] = INT_MAX, sptSet[i] = false;

	// Distance of source vertex from itself is always 0
	dist[src] = 0;

	// Find shortest path for all vertices
	for (int count = 0; count &lt; V - 1; count++) {
		// Pick the minimum distance vertex from the set of vertices not
		// yet processed. u is always equal to src in the first iteration.
		int u = minDistance(dist, sptSet);

		// Mark the picked vertex as processed
		sptSet[u] = true;

		// Update dist value of the adjacent vertices of the picked vertex.
		for (int v = 0; v &lt; V; v++)

			// Update dist[v] only if is not in sptSet, there is an edge from
			// u to v, and total weight of path from src to v through u is
			// smaller than current value of dist[v]
			if (!sptSet[v] &amp;&amp; graph[u][v] &amp;&amp; dist[u] != INT_MAX
				&amp;&amp; dist[u] + graph[u][v] &lt; dist[v])
				dist[v] = dist[u] + graph[u][v];
	}

	// print the constructed distance array
	printSolution(dist, V);
}

// driver program to test above function
int main()
{
	/* Let us create the example graph discussed above */
	int graph[V][V] = { { 0, 4, 0, 0, 0, 0, 0, 8, 0 },
						{ 4, 0, 8, 0, 0, 0, 0, 11, 0 },
						{ 0, 8, 0, 7, 0, 4, 0, 0, 2 },
						{ 0, 0, 7, 0, 9, 14, 0, 0, 0 },
						{ 0, 0, 0, 9, 0, 10, 0, 0, 0 },
						{ 0, 0, 4, 14, 10, 0, 2, 0, 0 },
						{ 0, 0, 0, 0, 0, 2, 0, 1, 6 },
						{ 8, 11, 0, 0, 0, 0, 1, 0, 7 },
						{ 0, 0, 2, 0, 0, 0, 6, 7, 0 } };

	dijkstra(graph, 0);

	return 0;
}
                                </code>
                            </pre>
                            <!-- <div data-pym-src="" style="width: 120%"></div>
                            <script src="https://www.jdoodle.com/assets/jdoodle-pym.min.js" type="text/javascript"></script> -->
                        </div>
                    </div>
                </li>
                <li>
                    <div>
                        <h2 id="6" onclick="buttonHeader(this.id)" style="text-align: center;">Quicksort Algorithm</h2>
                        <div id="61" style="display: none">
                            <img src="images/Algo_Quick_sort.gif" alt="" style="width: 70%; margin-left: 10%;">
                            <pre>
                                <code>/* C++ implementation of QuickSort */
#include &lt;bits/stdc++.h&gt;
using namespace std;

// A utility function to swap two elements
void swap(int* a, int* b)
{
	int t = *a;
	*a = *b;
	*b = t;
}

/* This function takes last element as pivot, places
the pivot element at its correct position in sorted
array, and places all smaller (smaller than pivot)
to left of pivot and all greater elements to right
of pivot */
int partition(int arr[], int low, int high)
{
	int pivot = arr[high]; // pivot
	int i
		= (low
		- 1); // Index of smaller element and indicates
				// the right position of pivot found so far

	for (int j = low; j &lt;= high - 1; j++) {
		// If current element is smaller than the pivot
		if (arr[j] &lt; pivot) {
			i++; // increment index of smaller element
			swap(&amp;arr[i], &amp;arr[j]);
		}
	}
	swap(&amp;arr[i + 1], &amp;arr[high]);
	return (i + 1);
}

/* The main function that implements QuickSort
arr[] --&gt; Array to be sorted,
low --&gt; Starting index,
high --&gt; Ending index */
void quickSort(int arr[], int low, int high)
{
	if (low &lt; high) {
		/* pi is partitioning index, arr[p] is now
		at right place */
		int pi = partition(arr, low, high);

		// Separately sort elements before
		// partition and after partition
		quickSort(arr, low, pi - 1);
		quickSort(arr, pi + 1, high);
	}
}

/* Function to print an array */
void printArray(int arr[], int size)
{
	int i;
	for (i = 0; i &lt; size; i++)
		cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}

// Driver Code
int main()
{
	int arr[] = { 10, 7, 8, 9, 1, 5 };
	int n = sizeof(arr) / sizeof(arr[0]);
	quickSort(arr, 0, n - 1);
	cout &lt;&lt; &quot;Sorted array: \n&quot;;
	printArray(arr, n);
	return 0;
}
                                </code>
                            </pre>
                            <!-- <div data-pym-src="" style="width: 120%"></div>
                            <script src="https://www.jdoodle.com/assets/jdoodle-pym.min.js" type="text/javascript"></script> -->
                        </div>
                    </div>
                </li>
                <li>
                    <div>
                        <h2 id="7" onclick="buttonHeader(this.id)" style="text-align: center;">Euclid's Algorithm</h2>
                        <div id="71" style="display: none">
                            <img src="images/Algo_Euclid.gif" alt="" style="width: 70%; margin-left: 10%; height: 70vh;">
                            <pre>
                                <code>
// C++ program to demonstrate
// Basic Euclidean Algorithm

#include &lt;bits/stdc++.h&gt;
using namespace std;

// Function to return
// gcd of a and b
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

// Driver Code
int main()
{
    int a = 10, b = 15;

    // Function call
    cout &lt;&lt; &quot;GCD(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;) = &quot; &lt;&lt; gcd(a, b)
        &lt;&lt; endl;
    a = 35, b = 10;
    cout &lt;&lt; &quot;GCD(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;) = &quot; &lt;&lt; gcd(a, b)
        &lt;&lt; endl;
    a = 31, b = 2;
    cout &lt;&lt; &quot;GCD(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;) = &quot; &lt;&lt; gcd(a, b)
        &lt;&lt; endl;
    return 0;
}
                                </code>
                            </pre>
                            <!-- <div data-pym-src="" style="width: 120%"></div>
                            <script src="https://www.jdoodle.com/assets/jdoodle-pym.min.js" type="text/javascript"></script> -->
                        </div>
                    </div>
                </li>
            </ol>
        </div>
        <div> 
            <img id="matrix" src="images/Algos_matrix.gif" alt="Matrix">
        </div>
    </div>
    <script>
        function buttonHeader(id){
            $('#'+id+'1').slideToggle("slow");
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"   ></script>
    <script>hljs.highlightAll();</script>
</body>
</html>